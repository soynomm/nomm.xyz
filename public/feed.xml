<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
    xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
    >
<channel>
    <title>Nomm</title>
    <atom:link href="https://soynomm.com/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>https://soynomm.com</link>
    <description>Nomm is a software engineer, this is his personal site and blog.</description>
    <lastBuildDate>Wed, 03 Mar 2021 00:00:00 +0000</lastBuildDate>
    <language>en</language>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
        <title>I&#39;m no longer a front-end developer</title>
        <link>https://soynomm.com/blog/im-no-longer-a-frontend-developer</link>
        <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
        <guid isPermaLink="false">https://soynomm.com/blog/im-no-longer-a-frontend-developer</guid>
        <description>Reflecting on my time at GPM and a path forward as an engineer.</description>
        <content:encoded><![CDATA[<p><a href="https://soynomm.com/blog/i-dont-want-to-do-frontend-anymore/">True to my word</a>, as of today I'm no longer a front-end developer. Yesterday
marked the last day as one, and also the last day at <a href="https://www.greenpowermonitor.com/">GPM</a>,
where I had spent my last 2 and a half years. The first two years I spent almost entirely
writing ClojureScript, which I must say is a joy to write, and the rest writing TypeScript,
which to me is like my colleagues know, a poor man's typed language.</p>
<p><strong>Funny story about GPM:</strong> I was new in Barcelona and needed a job, so I applied to a
few JavaScript positions, one of which was GPM. I had just one call with them
after which I received a formal offer. Once arriving in the offices to sign my
contract I found out that I will be doing ClojureScript instead, which if you don't know
is about as different from JavaScript as a thing could be. I also found out that
they had forgotten to send me a test job and that it was a bit late for that.
Seems all worked out despite these things, and if Clojure were a bit more popular, I'd probably
be looking to do back-end Clojure now.</p>
<p>I have no bad words about the company or the people I've worked with. I was told that
if I ever find myself in Barcelona again and would like to work for them again,
the door is always open - and while it would certainly have to be back-end for me then -
I really wouldn't mind. I've met amazing people there and will not miss a chance to
invite them for a drink whenever I find myself in Spain again.</p>
<p>So what's next for me? Well, if you read my post <a href="https://soynomm.com/blog/creating-a-static-site-generator-in-python/">on creating a static site generator in Python</a>,
you'd probably guess it was Python. I've done enough of
job market, developer happiness, and would-i-like-it research to be able to guess
with a pretty high probability that I'd be happy writing Python. But once I looked a bit closer into what <em>types</em> of jobs Python would mostly offer, I found it's either automation or data science. Automation is usually low-pay and data science isn't something I'm interested in, and so Python, for now at least, isn't going to work for me. I'll have to find something else.</p>
<p>I'm sure that the transition to back-end won't be an easy one as there are a lot of tools
and technologies I need to catch up with, as well as brush up on my algo's and data
structures. Believe it or not in my 10 years as an engineer, never really needed
too much of that. That said, I'm determined to become a back-end expert, and par for the course,
expert in data structures and algo's as well. After all, I've heard that it's
impossible to land a back-end job without knowing how to revert different types of trees.
Obviously, you'll need a shovel and possibly a crane of sorts.</p>
<p>I know some of you might cringe reading this and think I must not be so bright,
and perhaps you are right, but I managed to learn all of this on my own with no
mentors and no formal education, just a bunch of googling and of building a ton of
side projects, and I've done well for myself thus far, and
that's the only measure of success that matters to me. The way I see the world,
it's the only measure of success that should matter to anyone.</p>
<p>Here's to the next 10 years of software development, this time as a back-end developer.</p>
]]></content:encoded>
    </item>
    <item>
        <title>Parsing CLI arguments yourself in Java</title>
        <link>https://soynomm.com/blog/parsing-cli-arguments-yourself-in-java</link>
        <pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate>
        <guid isPermaLink="false">https://soynomm.com/blog/parsing-cli-arguments-yourself-in-java</guid>
        <description>Not everything has to be solved with a dependency - just like parsing CLI arguments can be done with a simple, straight-forward helper class that I can write myself.</description>
        <content:encoded><![CDATA[<p>If you're making a Java app that's meant to be used on the command line, there's a fair chance you'll also be using CLI arguments for that app. There's a few tools out there that help you with this like <a href="https://picocli.info">picocli</a>, but I figured the problem is such an insignificant one for me and my use-case that I won't need a full-featured thing like that for this. After all, I have all of the information that I could need in a provided array of strings already like this inside my Main class:</p>
<pre><code class="language-java">public class Main {
	public static void main(String[] args) {
		// we have the arguments in args
	}
}

</code></pre>
<p>Following the logic that I have a flag and that flag has an optional value, like <code>appName --flag {value}</code>. I'd have the command at index 0, its value (if it has any) on index 1. Following command on index 2 and its value on index 3, and so on. It's pretty straight-forward, and so is my solution to this. Let's get to it.</p>
<p>To start with, I created a class called <code>ArgParser</code>, like so:</p>
<pre><code class="language-java">public class ArgParser {

	private final String[] args;

}
</code></pre>
<p>As you can see, the class will hold in its state the raw form of args we receive in our <code>Main.main</code>. Now we need a constructor to put the args in the state when initializing <code>ArgParser</code>, so let's add it like this:</p>
<pre><code class="language-java">public class ArgParser {

    private final String[] args;

    public ArgParser(String[] args) {
        this.args = args;
    }

}
</code></pre>
<p>Now we can initialize the <code>ArgParser</code> like this:</p>
<pre><code class="language-java">public class Main {
	public static void main(String[] args) {
		ArgParser argParser = new ArgParser(args);
	}
}
</code></pre>
<p>It doesn't do anything yet, but it will shortly.</p>
<p>Next up I created a simple <code>has</code> method that checks if a given argument actually exists in <code>this.args</code> or not:</p>
<pre><code class="language-java">private boolean has(String arg) {
    return Arrays.asList(this.args).contains(arg);
}
</code></pre>
<p>You see I can call the <code>has</code> method like <code>this.has(&quot;argumentName&quot;)</code> and it will return <code>true</code> if the argument exists in <code>this.args</code>. Naturally it will return false otherwise. Now all there's left to do is to create a getter, but I don't want the getter to only return the argument's value - I also want it to return a default value that I provide if the argument either doesn't exist or doesn't have value. I made it happen like this:</p>
<pre><code class="language-java">public String get(String arg, String defaultValue) {
    if (this.has(arg)) {
        int index = Arrays.asList(args).indexOf(arg);

        try {
            return this.args[index + 1];
        } catch(java.lang.ArrayIndexOutOfBoundsException e) {
            return defaultValue;
        }
    }

    return defaultValue;
}
</code></pre>
<p>If the argument exists, it will try to find its value and return it. However if it doesn't have a value, we'll be hitting an <code>ArrayIndexOutOfBoundsException</code>, and in that case we return the default value. If the argument does not exist, we also return the default value.</p>
<p><strong>There's a slight bug in this code though</strong>. It's that if the provided arguments are like <code>appName --arg1 --arg2</code>, then by using our getter for <code>--arg1</code>, its value would be incorrectly <code>--arg2</code> and not the default value. I can fix this by checking that if it does find a value, it wouldn't start with a hyphen, like so:</p>
<pre><code class="language-java">public String get(String arg, String defaultValue) {
    if (this.has(arg)) {
        int index = Arrays.asList(args).indexOf(arg);

        try {
            String value = this.args[index + 1];

            if (value.charAt(0) != '-') {
                return value;
            }
        } catch(java.lang.ArrayIndexOutOfBoundsException e) {
            return defaultValue;
        }
    }

    return defaultValue;
}
</code></pre>
<p>So I can utilise this to make actual use of the freshly baked <code>ArgParser</code>:</p>
<pre><code class="language-java">public class Main {
	public static void main(String[] args) {
		ArgParser argParser = new ArgParser(args);
		String argValue = argParser.get(&quot;--arg&quot;, &quot;defaultValue&quot;);
	}
}
</code></pre>
<p>But what if I also want to have an alternative argument, say <code>--arg</code> and <code>-a</code> for short? Overloading comes to rescue here as I can create another <code>get</code> method that takes an additional String parameter:</p>
<pre><code class="language-java">public String get(String arg, String alternativeArg, String defaultValue) {
    if (!this.get(arg, &quot;&quot;).equals(&quot;&quot;)) {
        return this.get(arg, &quot;&quot;);
    }

    if (!this.get(alternativeArg, &quot;&quot;).equals(&quot;&quot;)) {
        return this.get(alternativeArg, &quot;&quot;);
    }

    return defaultValue;
}
</code></pre>
<p>So now I can utilise the <code>get</code> method like this:</p>
<pre><code class="language-java">public class Main {
	public static void main(String[] args) {
		ArgParser argParser = new ArgParser(args);
		String argValue = argParser.get(&quot;--arg&quot;, &quot;-a&quot;, &quot;defaultValue&quot;);
	}
}
</code></pre>
<p>And it would return a value for either of those arguments or the default value if none found.</p>
<p>But wait, there's an important piece missing here! What if I want a boolean result for if an argument exists or not? Say if I want to the argument to <em>not have</em> a value, and instead just want to know if it's present? Overloading comes to rescue once more! I'll create another <code>get</code> method that takes returns a boolean and takes a boolean as its default value:</p>
<pre><code class="language-java">public boolean get(String arg, String alternativeArg, boolean defaultValue) {
    if (this.has(arg) || this.has(alternativeArg)) {
        return true;
    }

    return defaultValue;
}
</code></pre>
<p>Now you could simply use:</p>
<pre><code class="language-java">public class Main {
	public static void main(String[] args) {
		ArgParser argParser = new ArgParser(args);
		boolean argValue = argParser.get(&quot;--arg&quot;, &quot;-a&quot;, false);
	}
}
</code></pre>
<p>And <code>argValue</code> will be <code>true</code> if either of the arguments are present and <code>false</code> otherwise. Pretty straight-forward, right?</p>
]]></content:encoded>
    </item>
    <item>
        <title>The Ghost Recruiter</title>
        <link>https://soynomm.com/blog/the-ghost-recruiter</link>
        <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
        <guid isPermaLink="false">https://soynomm.com/blog/the-ghost-recruiter</guid>
        <description>A story about a particular type of person who gives hope and then takes it away.</description>
        <content:encoded><![CDATA[<p>It's a Friday afternoon and you've just clocked out of a long work week. Work has been running you down lately. Maybe it's that you haven't had a decent vacation in a long time or maybe you're just tired of working on the same ol', same ol'. Maybe, just maybe, you could use a change. Suddenly, your phone lights up with a notification from your LinkedIn app with a title saying; &quot;Looking for a new opportunity?&quot;, as if you were wishing, and a genie was granting.</p>
<p>Now you write this recruiter saying something like; &quot;Wow how did you know?&quot; and; &quot;tell me more&quot;. The recruiter continues to give you information on this amazing company that is changing the world in a variety of ways and how you could contribute to the betterment of the world and sleep soundly at night knowing your hard work actually makes a difference. This company has an amazing work culture, uses all the latest, greatest, and just best tools. And it doesn't stop there.</p>
<p>Of course, you say yes. This is what you have been waiting for, even if unknowingly. Your subconscious has been longing for a change of pace to your otherwise pretty mundane existence. This is it. You feel re-energized, ready for anything. The recruiter tells you he has forwarded your application and that you'd be a perfect fit, and he'll keep you posted with an update as soon as humanly possible. You even start doing some algorithm exercises to make yourself the best you that you can be when the technical interview time arrives. You're unstoppable.</p>
<p>A few days go by and the recruiter not only writes you - but calls you. He goes on to reassure you that good things are coming and that your application is being reviewed already. The next step would be to have a call with the hiring manager and then have the technical screen. Everything is so damn close to becoming true that you can almost taste it, smell it.</p>
<p>Except that the next step never happens. You never hear back from the recruiter or the company in question. Feelings of great prosperity are quickly replaced by a sense of hollow sadness. &quot;What did I do wrong?&quot;, you ask yourself. &quot;Was it my personality?&quot;, &quot;Maybe my resume wasn't strong enough?&quot;, you contemplate. Before you fall into complete emotional disarray, you write to the recruiter, asking for an update. Days go by, nothing comes back. You'll be fine, of course. Shit like this happens. But every time it does, it takes a piece of you with it as the opportunity that could've been, wasn't. A peace of naive optimism, a good piece. And it replaces it with cold skepticism.</p>
<hr />
<p>The above is a somewhat exaggerated (for dramatic purposes) version of what really happens, but I, like many, have experienced this and while sure, the more you experience it the less you care about this sort of thing, you can't deny the negative effect it has on you and other people.</p>
<p>If you're a recruiter reading this, please don't be an asshole. If the person applying wasn't a suitable candidate, just tell them. And if you can, tell them also why. It may be uncomfortable to do so, but you'll be a better person for it and the candidate knows what to improve upon so that maybe the next opportunity that comes by will be <em>the</em> opportunity.</p>
]]></content:encoded>
    </item>
    <item>
        <title>Creating a static site generator in Python</title>
        <link>https://soynomm.com/blog/creating-a-static-site-generator-in-python</link>
        <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
        <guid isPermaLink="false">https://soynomm.com/blog/creating-a-static-site-generator-in-python</guid>
        <description>An exercise in learning how to write Python on the road to becoming a Python engineer</description>
        <content:encoded><![CDATA[<p>Usually when I start learning a new language I write some sort of a file parser. Not that I really have much utility for one, but because that seems to me to be a quick thing to build to get a general sense of how a language works. Now, <a href="https://soynomm.com/blog/i-dont-want-to-do-frontend-anymore/">as you may know</a> I've reached a point in my career where I'm doing a bit of a change and so I didn't think something as simple would really work anymore - I'd need to build something a bit more in depth.</p>
<p>First I needed to figure out what it is exactly that I want to do going forward. I knew I wanted to do back-end, but what language? Well, my wife is currently learning Java and I've heard there's lots of jobs in it so I checked Glassdoor for Java positions, lo' and behold, 267 job postings. There's just one problem with Java and it's a big one; I don't like it much. Then, clueless as to how to continue, I went over to the <a href="https://insights.stackoverflow.com/survey/2020">Stack Overflow 2020 survey results</a> and found that <a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-wanted">the most wanted language is Python</a>. Glassdoor says 300 job postings for Python! That's good news.</p>
<p>Engineers all over the world like Python, but would I? I've certainly heard of it before, but believe it or not I've never written a single line of code in it. I don't think I've ever as much as went on Python's website before. So then first thing I did was to think of what I could create to test Python out, and I remembered that my own blog was a dynamically generated site written in PHP, which while fast still required actual processing power to render, so I decided to turn the dynamic part into static and entirely cut out the middle man.</p>
<p>I decided to write a static site generator. Yeah, I know, there's millions of them out there - but I have never created one, so it seemed like a pretty good challenge to me. Especially to write in a language I know nothing about.</p>
<h2>It all starts with a .py file</h2>
<p>After a quick Google I learned that writing a Python application is as simple as creating a .py file and then executing it with <code>python -m filename.py</code>. That sounds simple enough, so I created this:</p>
<pre><code class="language-python">print('Hello, world')
</code></pre>
<p>And ran it. To my surprise, it just worked. I was expecting some weird tooling error or what-not, by PyCharm had created a virtualenv for my code and packaged the latest Python with it - as well as whatever else it needed to just run the code. We're in business.</p>
<p>So let's lay out a plan for the static site generator, like what exactly should it do? I figure it should scan through provided Markdown files, extract information from them and then generate good ol' HTML from a provided template file. Sounds simple enough right?</p>
<h2>Defining the content file' structure</h2>
<p>I really like what Jekyll does with the yaml-on-top structure for its content files, so I figure I steal the format. Content files would look like this:</p>
<pre><code>---
title: Hello, world
date: 2021-02-15
---

**Markdown** content follows here.
</code></pre>
<p>Meta-data like the title, date of the post and so on would sit on top of the file and the Markdown content below it. Easy-enough to parse as well.</p>
<h2>Finding all of the markdown files</h2>
<p>Much like in my dynamic site generator, the file path should correspond to the URL of the final site (because then we don't have to deal with routing), so we should start by finding all of the Markdown files and more importantly, their paths. To do that, I wrote this bit of recursive code:</p>
<pre><code class="language-python">def get_paths(from_path):
    paths = []
    items = os.listdir(from_path)

    for item in items:
        if item.endswith(&quot;.md&quot;):
            complete_path = (from_path + &quot;/&quot; + item)
            path = complete_path.replace(resources_dir + '/content', '')
            paths.append(path)
        else:
            paths.extend(get_paths(from_path + '/' + item))

    return paths
</code></pre>
<p>What it does is quite simple, it checks all of the files in a given <code>from_path</code>, iterates over each to find out if we're dealing with a <code>.md</code> file, and if yes, add the path to a list. If not, it's probably a directory and we should start the whole process over again on that new path. So it repeats until we have everything, then returns paths. I should probably make sure that the <code>else</code> block actually runs on a directory and not just for anything that <em>isn't</em> a Markdown file, but for now it'll suffice.</p>
<h2>Getting the content from the files</h2>
<p>Now that we have all the paths to the files we need and we know what the file structure is supposed to look like, we can move to the hardest bit of this all, which is parsing the file.</p>
<p>Let's begin with writing a function that takes the YAML-esque structure seen on top of the content file and turns it into a dictionary, like this:</p>
<pre><code class="language-python">def get_content_meta(content):
    meta_block = re.search('(?s)^---(.*?)---*', content)

    if meta_block:
        match = meta_block.group(0)
        meta_lines = match.splitlines()
        meta_lines = remove_spaces_from_around_items_in_list(meta_lines)
        meta_lines = remove_all_occurrences_from_list(meta_lines, '---')
        meta = {}

        for meta_line in meta_lines:
            if ':' in meta_line:
                key = meta_line.split(':')[0].strip().replace(' ', '_')
                key = re.sub('[^a-zA-Z_]', '', key)
                value = meta_line.split(':')[1].strip()
                meta[key] = value

        return meta
    else:
        return {}
</code></pre>
<p>It takes the whole content of the file as an input, finds the part that starts with three hyphens and ends with three hyphens (but only the first part like this, because you might have more!). It then continues to parse it into a dictionary, with help of some additional functions like <code>remove_spaces_from_around_items_in_list</code> and <code>remove_all_occurences_from_list</code>, all of which you can check out <a href="https://github.com/soynomm/bloggo/blob/master/bloggo/core.py">in the final product</a>. In the end it returns a parsed dictionary, or an empty dictionary if our expected structure was not found.</p>
<p>Moving on, we now need to get the Markdown bit of the file, which is a lot easier to get:</p>
<pre><code class="language-python">def get_content_entry(content):
    entry = re.sub('(?s)^---(.*?)---*', '', content)
    return entry.strip()
</code></pre>
<p>It uses the exact same regex pattern we used to get the YAML-esque data structure, except we now use it in the opposite way - by deleting that part from the content, because the resulting bit is surely our desired Markdown.</p>
<p>And now let's stitch this all together into this function:</p>
<pre><code class="language-python">def get_contents(paths):
    contents = []

    for path in paths:
        with open(resources_dir + &quot;/content&quot; + path, 'r') as reader:
            content = reader.read()
            meta = get_content_meta(content)
            entry = get_content_entry(content)
            contents.append({
                'path': path.replace('.md', ''),
                **meta,
                'entry': markdown.markdown(entry, extensions=['extra'])
            })

    return contents
</code></pre>
<p>Which takes an input of <code>paths</code> that we got with the <code>get_paths</code> function, iterates over each path, get's the file contents. It then continues to get the meta-data from it with our <code>get_content_meta</code> and <code>get_content_entry</code> functions. Once it has that, it puts it all together into a dictionary containing all the meta items, the <code>path</code> and the Markdown parsed <code>entry</code>. Basically everything we'd need to actually generate our HTML.</p>
<h2>Generating HTML</h2>
<p>We are pretty much set with everything we need to create a static site generator now, so let's create a function that creates the actual file:</p>
<pre><code class="language-python">def generate_file(content, config, template, helpers):
    print('Generating ' + content['path'])
    compiler = pybars.Compiler()
    compiled_template = compiler.compile(template)
    output = compiled_template({**config, **content}, helpers=helpers)
    file_path = out_dir + content['path'] + '/index.html'

    if not os.path.exists(os.path.dirname(file_path)):
        try:
            os.makedirs(os.path.dirname(file_path))
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

    file = open(file_path, 'w')
    file.write(output)
    file.close()
</code></pre>
<p>There's a few things to note here. One is the the first argument, <code>content</code>, which is the dictionary result of a singular item from the <code>get_contents</code> function containing various things in it like post title, date, etc. The next argument is <code>config</code>, this is also a dictionary containing extra configuration information for the Handlebars template (we'll see more on this in a bit). Then, the third argument is <code>template</code>, which is the actual Handlebars file contents we use to put together the final HTML and last we have <code>helpers</code>, which is a dictionary of all the Handlebars helpers that we can pass along to it.</p>
<p>It puts this all together, tries to create all the directory paths to the desired end destination and then creates a <code>index.html</code> file in it with our generated HTML.</p>
<p>And the bit that actually calls <code>generate_file</code> is this:</p>
<pre><code class="language-python">def generate_files(contents):
    with open(resources_dir + '/template.hbs', 'r') as template_file, \
            open(resources_dir + '/config.json', 'r') as config_file:
        template = template_file.read()
        config = config_file.read()
        blog_paths = get_paths(resources_dir + '/content/blog')
        blog_contents = get_contents(blog_paths)
        helpers = {'format_date': hbs.format_date}
        site_config = json.loads(config)
        post_config = {'is_home': False, 'is_post': True}
        home_config = {
            'is_home': True,
            'is_post': False,
            'posts': blog_contents
        }

        # Generate all content
        for content in contents:
            generate_file(content,
                          {**post_config, **site_config},
                          template,
                          helpers)

        # Generate home page
        generate_file({'path': '/', 'entry': ''},
                      {**home_config, **site_config},
                      template,
                      helpers)
</code></pre>
<p>Now it should make more sense to you what <code>generate_file</code> does as you can see how the <code>config</code>, <code>template</code> and <code>helpers</code> arguments get constructed. It opens two files, both of which we need - the template Handlebars file and the global config.json that you as a user can edit to create new global variables for use within the Handlebars template.</p>
<h2>To conclude</h2>
<p>This all makes up a static site generator I have called <a href="https://github.com/soynomm/bloggo">Bloggo</a>, and it runs this very site. There's a bit more to it than this blog post details and if you're curious then <a href="https://github.com/soynomm/bloggo">you can go browse all of it on Github</a>.</p>
<p>Overall I'm quite happy with the result. I managed to make something I had never made before and also learn a new language. I do realise that this use-case obviously only gives me minimal exposure to the vast ecosystem of Python, but I did learn quite a few things - like how to create a Pypi package, basic syntax and so on. And damn, the language is a pure joy to write. I like it a lot.</p>
]]></content:encoded>
    </item>
    <item>
        <title>I don&#39;t want to do front-end anymore</title>
        <link>https://soynomm.com/blog/i-dont-want-to-do-frontend-anymore</link>
        <pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate>
        <guid isPermaLink="false">https://soynomm.com/blog/i-dont-want-to-do-frontend-anymore</guid>
        <description>Front-end is not something that makes me happy anymore, in large part due to its complexity.</description>
        <content:encoded><![CDATA[<p>I started coding when I was 14, around 2007 or so. The very first thing I wrote was HTML, then CSS. I liked
making stupid little web pages containing youtube embeds and guest books (anyone remembers those?) full of
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/marquee">marquees</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blink">blinks</a>
and gifs. Lots of gifs. The pages were very simple, but joyful to make and also to use. At the time I had no idea that
you could make any money with making web pages, I simply thought it was a silly hobby people could have.</p>
<p>Fast-forward 3 years I got my first few gigs as a web developer. By then I was pretty good at HTML and CSS already,
had dabbled enough with PHP to know my way around most sticky problems I would find myself in and while I didn't
really know much of vanilla JavaScript, it was okay, because everyone used almost exclusively <a href="https://jquery.com/">jQuery</a> anyway. Yet still,
the websites were rather simple and joyful to make.</p>
<p>It was easy to get started, too - you just created the files and refreshed the page. HTML? PHP? JavaScript? Just create the
file and save it, then refresh the browser. Rinse and repeat until you are happy with the result. But then, almost
out of nowhere, something changed. At first, it came slowly and before it could even speed up, it was already here.
<strong>The complicated web was here</strong>.</p>
<p>Nowadays I make a living mainly with JavaScript and TypeScript using React.js as a front-end framework. That's right,
front-ends are so complex they now need frameworks to be able to manage their seemingly infinite component hierarchies.
JavaScript no longer is liked by the community, so the community created a poor man's version of a typed language which
duct-tapes around an <a href="https://whydoesitsuck.com/why-does-javascript-suck/">already poorly made language</a>.</p>
<p>Starting a new project? Make sure to write your project idea down because by the time you are finished setting up the vast
boilerplate you have probably forgotten it. Vast boilerplate? Oh yeah, you better set-up your project with <a href="https://www.typescriptlang.org/">TypeScript</a>,
<a href="https://eslint.org/">ESlint</a>, <a href="https://webpack.js.org/">Webpack</a> and <a href="https://babeljs.io/">Babel</a>, because
if you don't then obviously you haven't learned anything since 2005 and suck. Don't have <a href="https://www.npmjs.com/">NPM</a>? Better install that, too,
because nobody installs libraries without a package manager anymore. Oh and while you're at it, install also <a href="https://yarnpkg.com/">Yarn</a>,
because why not make use of two package managers at the same time. <em>Phew</em>, you did all that? Damn, that's commitment!
You can finally write what is essentially just HTML and JavaScript!</p>
<p>Now, don't forget we also want to style our project, but if you thought you could get away with writing good ol' CSS,
you were wrong. We no longer write CSS, because it's lame. We now write <a href="https://sass-lang.com/">SCSS</a> instead,
so that we could write dynamic stylesheets that convert to CSS, because <a href="https://hospodarets.com/you-might-not-need-a-css-preprocessor">of course 99% of the web needs that</a>.</p>
<p>But enough of the hating. If I wanted I could hate on anything most likely, and the web has come a long way since 2007,
in lots of good ways, and I don't want to discredit that. I suppose with the increase of complexity in what we want to
achieve on the web the stack to achieve it with has had to also increase in complexity. For me, personally, it's
too much. I want to have a personal life and not have to spend my nights reading up on some new flavour of *.js in
fear that if I don't I would soon be made irrelevant. I don't want to learn nor use a million different tools. I don't want
to know a bit about everything and a lot about nothing.</p>
<p>Thus, I don't want to do front-end development anymore. The joy is gone. I've given in my resignation at my current place of
employment and will be seeking an exclusively back-end role for my next adventure, starting April. The language doesn't
matter much to me, I know enough of them to know that they are all very similar and thus easy enough to learn. If you know of a
good opportunity, <a href="mailto:nomm@soynomm.com">let me know</a>.</p>
]]></content:encoded>
    </item>
</channel>
</rss>