
    <?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:wfw="http://wellformedweb.org/CommentAPI/"
        xmlns:dc="http://purl.org/dc/elements/1.1/"
        xmlns:atom="http://www.w3.org/2005/Atom"
        xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
        xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
        >
    <channel>
        <title>Nomm</title>
        <atom:link href="/feed.xml" rel="self" type="application/rss+xml"></atom:link>
        <link>https://soynomm.com</link>
        <description>Nomm is a software engineer, this is his personal site and blog.</description>
        <lastBuildDate>Fri, 05 Feb 2021 21:41:44 +0000</lastBuildDate>
        <language>en</language>
        <sy:updatePeriod>hourly</sy:updatePeriod>
        <sy:updateFrequency>1</sy:updateFrequency>
        <item>
            <title>Creating a static site generator in Python</title>
            <link>https://soynomm.com/blog/creating-a-static-site-generator-in-python</link>
            <pubDate>2021-02-15</pubDate>
            <description>An exercise in learning how to write Python on the road to becoming a Python engineer</description>
            <content:encoded><![CDATA[<p>Usually when I start learning a new language I write some sort of a file parser. Not that I really have much utility for one, but because that seems to me to be a quick thing to build to get a general sense of how a language works. Now, <a href="https://www.askonomm.com/blog/i-dont-want-to-do-frontend-anymore/">as you may know</a> I've reached a point in my career where I'm doing a bit of a change and so I didn't think something as simple would really work anymore - I'd need to build something a bit more in depth.</p>
<p>First I needed to figure out what it is exactly that I want to do going forward. I knew I wanted to do back-end, but what language? Well, my wife is currently learning Java and I've heard there's lots of jobs in it so I checked Glassdoor for Java positions, lo' and behold, 267 job postings. There's just one problem with Java and it's a big one; I don't like it much. Then, clueless as to how to continue, I went over to the <a href="https://insights.stackoverflow.com/survey/2020">Stack Overflow 2020 survey results</a> and found that <a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-wanted">the most wanted language is Python</a>. Glassdoor says 300 job postings for Python! That's good news.</p>
<p>Engineers all over the world like Python, but would I? I've certainly heard of it before, but believe it or not I've never written a single line of code in it. I don't think I've ever as much as went on Python's website before. So then first thing I did was to think of what I could create to test Python out, and I remembered that my own blog was a dynamically generated site written in PHP, which while fast still required actual processing power to render, so I decided to turn the dynamic part into static and entirely cut out the middle man. </p>
<p>I decided to write a static site generator. Yeah, I know, there's millions of them out there - but I have never created one, so it seemed like a pretty good challenge to me. Especially to write in a language I know nothing about.</p>
<h2>It all starts with a .py file</h2>
<p>After a quick Google I learned that writing a Python application is as simple as creating a .py file and then executing it with <code>python -m filename.py</code>. That sounds simple enough, so I created this:</p>
<pre><code class="language-python">print('Hello, world')
</code></pre>
<p>And ran it. To my surprise, it just worked. I was expecting some weird tooling error or what-not, by PyCharm had created a virtualenv for my code and packaged the latest Python with it - as well as whatever else it needed to just run the code. We're in business.</p>
<p>So let's lay out a plan for the static site generator, like what exactly should it do? I figure it should scan through provided Markdown files, extract information from them and then generate good ol' HTML from a provided template file. Sounds simple enough right?</p>
<h2>Defining the content file' structure</h2>
<p>I really like what Jekyll does with the yaml-on-top structure for its content files, so I figure I steal the format. Content files would look like this:</p>
<pre><code>---
title: Hello, world
date: 2021-02-15
---

**Markdown** content follows here.
</code></pre>
<p>Meta-data like the title, date of the post and so on would sit on top of the file and the Markdown content below it. Easy-enough to parse as well.</p>
<h2>Finding all of the markdown files</h2>
<p>Much like in my dynamic site generator, the file path should correspond to the URL of the final site (because then we don't have to deal with routing), so we should start by finding all of the Markdown files and more importantly, their paths. To do that, I wrote this bit of recursive code:</p>
<pre><code class="language-python">def get_paths(from_path):
    paths = []
    items = os.listdir(from_path)

    for item in items:
        if item.endswith(&quot;.md&quot;):
            complete_path = (from_path + &quot;/&quot; + item)
            path = complete_path.replace(resources_dir + '/content', '')
            paths.append(path)
        else:
            paths.extend(get_paths(from_path + '/' + item))

    return paths
</code></pre>
<p>What it does is quite simple, it checks all of the files in a given <code>from_path</code>, iterates over each to find out if we're dealing with a <code>.md</code> file, and if yes, add the path to a list. If not, it's probably a directory and we should start the whole process over again on that new path. So it repeats until we have everything, then returns paths. I should probably make sure that the <code>else</code> block actually runs on a directory and not just for anything that <em>isn't</em> a Markdown file, but for now it'll suffice.</p>
<h2>Getting the content from the files</h2>
<p>Now that we have all the paths to the files we need and we know what the file structure is supposed to look like, we can move to the hardest bit of this all, which is parsing the file. </p>
<p>Let's begin with writing a function that takes the YAML-esque structure seen on top of the content file and turns it into a dictionary, like this:</p>
<pre><code class="language-python">def get_content_meta(content):
    meta_block = re.search('(?s)^---(.*?)---*', content)

    if meta_block:
        match = meta_block.group(0)
        meta_lines = match.splitlines()
        meta_lines = remove_spaces_from_around_items_in_list(meta_lines)
        meta_lines = remove_all_occurrences_from_list(meta_lines, '---')
        meta = {}

        for meta_line in meta_lines:
            if ':' in meta_line:
                key = meta_line.split(':')[0].strip().replace(' ', '_')
                key = re.sub('[^a-zA-Z_]', '', key)
                value = meta_line.split(':')[1].strip()
                meta[key] = value

        return meta
    else:
        return {}
</code></pre>
<p>It takes the whole content of the file as an input, finds the part that starts with three hyphens and ends with three hyphens (but only the first part like this, because you might have more!). It then continues to parse it into a dictionary, with help of some additional functions like <code>remove_spaces_from_around_items_in_list</code> and <code>remove_all_occurences_from_list</code>, all of which you can check out <a href="https://github.com/askonomm/bloggo/blob/master/bloggo/core.py">in the final product</a>. In the end it returns a parsed dictionary, or an empty dictionary if our expected structure was not found.</p>
<p>Moving on, we now need to get the Markdown bit of the file, which is a lot easier to get:</p>
<pre><code class="language-python">def get_content_entry(content):
    entry = re.sub('(?s)^---(.*?)---*', '', content)
    return entry.strip()
</code></pre>
<p>It uses the exact same regex pattern we used to get the YAML-esque data structure, except we now use it in the opposite way - by deleting that part from the content, because the resulting bit is surely our desired Markdown. </p>
<p>And now let's stitch this all together into this function:</p>
<pre><code class="language-python">def get_contents(paths):
    contents = []

    for path in paths:
        with open(resources_dir + &quot;/content&quot; + path, 'r') as reader:
            content = reader.read()
            meta = get_content_meta(content)
            entry = get_content_entry(content)
            contents.append({
                'path': path.replace('.md', ''),
                **meta,
                'entry': markdown.markdown(entry, extensions=['extra'])
            })

    return contents
</code></pre>
<p>Which takes an input of <code>paths</code> that we got with the <code>get_paths</code> function, iterates over each path, get's the file contents. It then continues to get the meta-data from it with our <code>get_content_meta</code> and <code>get_content_entry</code> functions. Once it has that, it puts it all together into a dictionary containing all the meta items, the <code>path</code> and the Markdown parsed <code>entry</code>. Basically everything we'd need to actually generate our HTML.</p>
<h2>Generating HTML</h2>
<p>We are pretty much set with everything we need to create a static site generator now, so let's create a function that creates the actual file:</p>
<pre><code class="language-python">def generate_file(content, config, template, helpers):
    print('Generating ' + content['path'])
    compiler = pybars.Compiler()
    compiled_template = compiler.compile(template)
    output = compiled_template({**config, **content}, helpers=helpers)
    file_path = out_dir + content['path'] + '/index.html'

    if not os.path.exists(os.path.dirname(file_path)):
        try:
            os.makedirs(os.path.dirname(file_path))
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise

    file = open(file_path, 'w')
    file.write(output)
    file.close()
</code></pre>
<p>There's a few things to note here. One is the the first argument, <code>content</code>, which is the dictionary result of a singular item from the <code>get_contents</code> function containing various things in it like post title, date, etc. The next argument is <code>config</code>, this is also a dictionary containing extra configuration information for the Handlebars template (we'll see more on this in a bit). Then, the third argument is <code>template</code>, which is the actual Handlebars file contents we use to put together the final HTML and last we have <code>helpers</code>, which is a dictionary of all the Handlebars helpers that we can pass along to it.</p>
<p>It puts this all together, tries to create all the directory paths to the desired end destination and then creates a <code>index.html</code> file in it with our generated HTML.</p>
<p>And the bit that actually calls <code>generate_file</code> is this:</p>
<pre><code class="language-python">def generate_files(contents):
    with open(resources_dir + '/template.hbs', 'r') as template_file, \
            open(resources_dir + '/config.json', 'r') as config_file:
        template = template_file.read()
        config = config_file.read()
        blog_paths = get_paths(resources_dir + '/content/blog')
        blog_contents = get_contents(blog_paths)
        helpers = {'format_date': hbs.format_date}
        site_config = json.loads(config)
        post_config = {'is_home': False, 'is_post': True}
        home_config = {
            'is_home': True,
            'is_post': False,
            'posts': blog_contents
        }

        # Generate all content
        for content in contents:
            generate_file(content,
                          {**post_config, **site_config},
                          template,
                          helpers)

        # Generate home page
        generate_file({'path': '/', 'entry': ''},
                      {**home_config, **site_config},
                      template,
                      helpers)
</code></pre>
<p>Now it should make more sense to you what <code>generate_file</code> does as you can see how the <code>config</code>, <code>template</code> and <code>helpers</code> arguments get constructed. It opens two files, both of which we need - the template Handlebars file and the global config.json that you as a user can edit to create new global variables for use within the Handlebars template.</p>
<h2>To conclude</h2>
<p>This all makes up a static site generator I have called <a href="https://github.com/askonomm/bloggo">Bloggo</a>, and it runs this very site. There's a bit more to it than this blog post details and if you're curious then <a href="https://github.com/askonomm/bloggo">you can go browse all of it on Github</a>. </p>
<p>Overall I'm quite happy with the result. I managed to make something I had never made before and also learn a new language. I do realise that this use-case obviously only gives me minimal exposure to the vast ecosystem of Python, but I did learn quite a few things - like how to create a Pypi package, basic syntax and so on. And damn, the language is a pure joy to write. I like it a lot.</p>]]></content:encoded>
        </item>
        <item>
            <title>I don&#x27;t want to do front-end anymore</title>
            <link>https://soynomm.com/blog/i-dont-want-to-do-frontend-anymore</link>
            <pubDate>2021-02-08</pubDate>
            <description>Front-end is not something that makes me happy anymore, in large part due to its complexity.</description>
            <content:encoded><![CDATA[<p>I started coding when I was 14, around 2007 or so. The very first thing I wrote was HTML, then CSS. I liked
making stupid little web pages containing youtube embeds and guest books (anyone remembers those?) full of 
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/marquee">marquees</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blink">blinks</a> 
and gifs. Lots of gifs. The pages were very simple, but joyful to make and also to use. At the time I had no idea that 
you could make any money with making web pages, I simply thought it was a silly hobby people could have.</p>
<p>Fast-forward 3 years I got my first few gigs as a web developer. By then I was pretty good at HTML and CSS already, 
had dabbled enough with PHP to know my way around most sticky problems I would find myself in and while I didn't 
really know much of vanilla JavaScript, it was okay, because everyone used almost exclusively <a href="https://jquery.com/">jQuery</a> anyway. Yet still, 
the websites were rather simple and joyful to make.</p>
<p>It was easy to get started, too - you just created the files and refreshed the page. HTML? PHP? JavaScript? Just create the
file and save it, then refresh the browser. Rinse and repeat until you are happy with the result. But then, almost
out of nowhere, something changed. At first, it came slowly and before it could even speed up, it was already here.
<strong>The complicated web was here</strong>.</p>
<p>Nowadays I make a living mainly with JavaScript and TypeScript using React.js as a front-end framework. That's right, 
front-ends are so complex they now need frameworks to be able to manage their seemingly infinite component hierarchies.
JavaScript no longer is liked by the community, so the community created a poor man's version of a typed language which 
duct-tapes around an <a href="https://whydoesitsuck.com/why-does-javascript-suck/">already poorly made language</a>. </p>
<p>Starting a new project? Make sure to write your project idea down because by the time you are finished setting up the vast
boilerplate you have probably forgotten it. Vast boilerplate? Oh yeah, you better set-up your project with <a href="https://www.typescriptlang.org/">TypeScript</a>, 
<a href="https://eslint.org/">ESlint</a>, <a href="https://webpack.js.org/">Webpack</a> and <a href="https://babeljs.io/">Babel</a>, because 
if you don't then obviously you haven't learned anything since 2005 and suck. Don't have <a href="https://www.npmjs.com/">NPM</a>? Better install that, too, 
because nobody installs libraries without a package manager anymore. Oh and while you're at it, install also <a href="https://yarnpkg.com/">Yarn</a>, 
because why not make use of two package managers at the same time. <em>Phew</em>, you did all that? Damn, that's commitment! 
You can finally write what is essentially just HTML and JavaScript!</p>
<p>Now, don't forget we also want to style our project, but if you thought you could get away with writing good ol' CSS, 
you were wrong. We no longer write CSS, because it's lame. We now write <a href="https://sass-lang.com/">SCSS</a> instead, 
so that we could write dynamic stylesheets that convert to CSS, because <a href="https://hospodarets.com/you-might-not-need-a-css-preprocessor">of course 99% of the web needs that</a>. </p>
<p>But enough of the hating. If I wanted I could hate on anything most likely, and the web has come a long way since 2007, 
in lots of good ways, and I don't want to discredit that. I suppose with the increase of complexity in what we want to 
achieve on the web the stack to achieve it with has had to also increase in complexity. For me, personally, it's 
too much. I want to have a personal life and not have to spend my nights reading up on some new flavour of *.js in 
fear that if I don't I would soon be made irrelevant. I don't want to learn nor use a million different tools. I don't want 
to know a bit about everything and a lot about nothing. </p>
<p>Thus, I don't want to do front-end development anymore. The joy is gone. I've given in my resignation at my current place of
employment and will be seeking an exclusively back-end role for my next adventure, starting April. The language doesn't 
matter much to me, I know enough of them to know that they are all very similar and thus easy enough to learn. If you know of a 
good opportunity, <a href="mailto:asko@askonomm.com">let me know</a>.</p>]]></content:encoded>
        </item>
        <item>
            <title>The Ghost Recruiter</title>
            <link>https://soynomm.com/blog/the-ghost-recruiter</link>
            <pubDate>2020-10-20</pubDate>
            <description></description>
            <content:encoded><![CDATA[<p>:)</p>]]></content:encoded>
        </item>
    </channel>
    </rss>
    